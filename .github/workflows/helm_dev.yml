name: Helm Deploy [Dev]

on:
  push:
    paths:
      - "deploy/helm/**"
      - ".github/workflows/helm_dev.yml"
    branches: [ "develop" ]
  
  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# jobì€ ì‚¬ìš©ìê°€ ì •í•œ í”Œë«í¼ì„ í†µí•´ steps ë¼ëŠ” ì¼ë ¨ì˜ ê³¼ì •ì„ ì‹¤í–‰.
# ì—¬ëŸ¬ ê°œì˜ job ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìœ¼ë©°, ì—¬ëŸ¬ ê°œì˜ job ì„ ì‚¬ìš©í•  ë•ŒëŠ” ì„œë¡œ ì •ë³´ë„ êµí™˜ ê°€ëŠ¥.
# ê°ê° ë…ë¦½ì ìœ¼ë¡œë„ ì‹¤í–‰ ê°€ëŠ¥.
jobs:
  build:
    name: Build
    
    runs-on: ubuntu-latest
    
    steps:
      - name: Check out source code
        uses: actions/checkout@v4
        with:
          ref: 'develop'
      
      # Necessary dir Check
      - name: media & static dir check
        uses: garygrossgarten/github-action-ssh@release
        with:
          host: ${{ secrets.NFS_HOST }}
          username: ${{ secrets.NFS_USER }}
          password: ${{ secrets.NFS_PASS }}
          command: |
            cd ${{ secrets.NFS_PATH }}/dev && \
            mkdir -p ./app/django/media && \
            echo '${{ secrets.NFS_PASS }}' | sudo -S chmod -R 775 ./app/django

      # ğŸ‘‡ ë³µì‚¬ ì „ì— ì‚­ì œ!
      - name: Clean existing helm dir on CI/CD server
        uses: garygrossgarten/github-action-ssh@release
        with:
          host: ${{ secrets.CICD_HOST }}
          username: ${{ secrets.CICD_USER }}
          password: ${{ secrets.CICD_PASS }}
          command: |
            rm -rf ${{ secrets.CICD_PATH }}/dev/deploy/helm
      
      # Helm source to CI/CD server copy transfer
      - name: Copy helm, to CI/CD server
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.CICD_HOST }}
          username: ${{ secrets.CICD_USER }}
          password: ${{ secrets.CICD_PASS }}
          source: 'deploy/helm,deploy/kubectl'
          target: ${{ secrets.CICD_PATH }}/dev/
      
      # helm upgrade --> install
      - name: SSH Remote Commands from ci/cd server
        uses: garygrossgarten/github-action-ssh@release
        with:
          host: ${{ secrets.CICD_HOST }}
          username: ${{ secrets.CICD_USER }}
          password: ${{ secrets.CICD_PASS }}
          command: |
            if ! helm repo list | grep -q 'nfs-subdir-external-provisioner'; then
              helm repo add nfs-subdir-external-provisioner https://kubernetes-sigs.github.io/nfs-subdir-external-provisioner
            fi
            if ! helm status nfs-subdir-external-provisioner -n kube-system >/dev/null 2>&1; then
              helm upgrade --install nfs-subdir-external-provisioner \
                nfs-subdir-external-provisioner/nfs-subdir-external-provisioner \
                  -n kube-system \
                  --set nfs.server=${{ secrets.CICD_HOST }} \
                  --set nfs.path=/mnt/nfs-subdir-external-provisioner
            fi
            cd ${{ secrets.CICD_PATH }}/dev
            kubectl apply -f deploy/kubectl/class-roles; cd deploy/helm
            
            helm upgrade ${{ secrets.DATABASE_USER }} . -f ./values-dev.yaml \
            --install -n ibs-dev --create-namespace --history-max 5 --wait --timeout 10m \
            --set global.dbPassword=${{ secrets.DATABASE_PASS }} \
            --set global.cicdPath=${{ secrets.CICD_PATH }} \
            --set global.cicdServerHost=${{ secrets.CICD_HOST }} \
            --set global.nfsPath=${{ secrets.NFS_PATH }} \
            --set global.nfsServerHost=${{ secrets.NFS_HOST }} \
            --set global.domainHost=${{ secrets.DOMAIN_HOST }} \
            --set global.emailHost=${{ secrets.EMAIL_HOST }} \
            --set global.emailHostUser=${{ secrets.EMAIL_HOST_USER }} \
            --set-string global.emailHostPassword='${{ secrets.EMAIL_HOST_PASSWORD }}' \
            --set global.defaultFromEmail=${{ secrets.EMAIL_DEFAULT_FROM }} \
            --set postgres.auth.postgresPassword=${{ secrets.DATABASE_PASS }} \
            --set postgres.auth.password=${{ secrets.DATABASE_PASS }} \
            --set postgres.auth.replicationPassword=${{ secrets.DATABASE_PASS }} \
            --set 'nginx.ingress.hosts[0].host'=dev.${{ secrets.DOMAIN_NAME }} \
            --set 'nginx.ingress.hosts[1].host'=dev.brdnc.co.kr \
            --set 'nginx.ingress.hosts[0].paths[0].path'=/ \
            --set 'nginx.ingress.hosts[0].paths[0].pathType'=Prefix \
            --set 'nginx.ingress.hosts[1].paths[0].path'=/ \
            --set 'nginx.ingress.hosts[1].paths[0].pathType'=Prefix \
            --set 'nginx.ingress.tls[0].hosts[0]'=dev.${{ secrets.DOMAIN_NAME }} \
            --set 'nginx.ingress.tls[0].hosts[1]'=dev.brdnc.co.kr \
            --set 'nginx.ingress.tls[0].secretName'=web-devbox-kr-cert
      #            --atomic --cleanup-on-fail
      
      # slack --> notification
      - name: Send slack when failed
        if: ${{ failure() }}                    # ì‹¤íŒ¨í–ˆì„ ë•Œ ì‹¤í–‰
        uses: ./.github/actions/slack-notify    # ì§ì ‘ 'ë§Œë“ ' Actionì´ë¯€ë¡œ uses í‚¤ì›Œë“œë¥¼ ì´ìš©í•´ì„œ ì•„ë˜ ê²½ë¡œë¥¼ ì…ë ¥í•´ì¤ë‹ˆë‹¤.
        with:
          slack_incoming_url: ${{ secrets.SLACK_INCOMING_URL }}

      - name: Send slack if completed
        if: ${{ success() }}                    # ì„±ê³µí•  ë•Œë§Œ ì‹¤í–‰
        uses: ./.github/actions/slack-notify
        with:
          status: success   # status inputì€ ë°›ëŠ” ìª½ì—ì„œ default ê°’ì„ ì •í•´ë†¨ê¸° ë•Œë¬¸ì— successì¼ ë•Œë§Œ ì „ë‹¬.
          slack_incoming_url: ${{ secrets.SLACK_INCOMING_URL }}
