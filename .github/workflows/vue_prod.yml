name: Vue [Prod]

on:
  push:
    paths:
      - "app/vue/**"
      - ".github/workflows/vue_prod.yml"
    branches: [ "master" ]
  
  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# job은 사용자가 정한 플랫폼을 통해 steps 라는 일련의 과정을 실행.
# 여러 개의 job 을 사용할 수 있으며, 여러 개의 job 을 사용할 때는 서로 정보도 교환 가능.
# 각각 독립적으로도 실행 가능.
jobs:
  build:
    name: Build
    runs-on: ubuntu-latest
    
    steps:
      # 레파지터리 체크 아웃
      - name: Check out source code
        uses: actions/checkout@v4
      
      # Node.js 사용
      - name: Use Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 24
      
      # pnpm use
      - uses: pnpm/action-setup@v4
        name: Install pnpm
        with:
          version: 10
          run_install: false
      
      # node_modules 캐싱
      - name: Cache vue node
        uses: actions/cache@v3
        id: cache_vue
        with:
          path: ./app/vue/node_modules
          key: pnpm-packages-${{ hashFiles('**/pnpm-lock.yaml') }}
      
      # node_modules 변화기 있으면 빌드
      - name: Install Dependencies
        if: steps.cache_vue.outputs.cache-hit != 'true'
        run: cd app/vue && pnpm i
      
      #      - run: pnpm lint
      #        # `if: ${{ always() }}`
      #        # 만약 `pnpm lint`라는 곳에서 에러가 났을 경우 이후 build를 실행하지 않고 해당 workflow가 종료됨.
      #        # `if: ${{ always() }}`라는 문법을 사용 시 `pnpm lint`라는 곳에서 에러가 나도
      #        # 이후의 build까지 다 실행을 해보고 난 뒤 종료 하므로 모든 테스트 스크립트에 `if: ${{ always() }}`를 붙임.
      #        if: ${{ always() }}
      
      # setup and lint 에러가 없으면 빌드
      - name: Build the Source Code
        env:
          NODE_ENV: production
          BUILD_TIMESTAMP: ${{ github.run_number }}_${{ github.sha }}
        run: |
          cd app/vue
          # 타임스탬프 디렉터리로 빌드
          export BUILD_DIR="../django/static/dist_${BUILD_TIMESTAMP}"
          pnpm build && pnpm docs:build

      # 배포 메타데이터 생성
      - name: Create deployment metadata
        env:
          BUILD_TIMESTAMP: ${{ github.run_number }}_${{ github.sha }}
        run: |
          cd app/django/static
          echo "{
            \"build_time\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\",
            \"git_sha\": \"${{ github.sha }}\",
            \"git_branch\": \"${{ github.ref_name }}\",
            \"build_number\": \"${{ github.run_number }}\",
            \"deployer\": \"${{ github.actor }}\"
          }" > dist_${BUILD_TIMESTAMP}/deploy.json

      # 빌드 검증
      - name: Verify Production Build
        env:
          BUILD_TIMESTAMP: ${{ github.run_number }}_${{ github.sha }}
        run: |
          cd app/django/static/dist_${BUILD_TIMESTAMP}

          echo "🔍 Verifying production build..."

          # index.html 존재 확인
          if [ ! -f "index.html" ]; then
            echo "❌ ERROR: index.html not found!"
            exit 1
          fi

          # base path 검증 (/static/dist 경로 사용 확인)
          if ! grep -q '/static/dist/assets/' index.html; then
            echo "❌ ERROR: Build base path incorrect! Expected '/static/dist/assets/'"
            echo "Found paths:"
            grep -o 'src="[^"]*"' index.html | head -5
            exit 1
          fi

          # console.log 제거 확인 (경고만)
          if find assets -name "*.js" -exec grep -l 'console\.log' {} \; 2>/dev/null | grep -q .; then
            echo "⚠️  WARNING: Console logs found in production build"
          fi

          # sourcemap 제외 확인 (경고만)
          if find assets -name "*.map" 2>/dev/null | grep -q .; then
            echo "⚠️  WARNING: Sourcemap files found in production build"
          fi

          echo "✅ Production build verification passed"
          echo "📊 Build stats:"
          echo "  - index.html: $(wc -c < index.html) bytes"
          echo "  - Total assets: $(find assets -type f | wc -l) files"
          echo "  - Total size: $(du -sh assets | cut -f1)"

      # 단위 테스트
      - name: Vue Unit Test using Vitest
        run: cd app/vue && pnpm test:unit

      # docs 배포
      - name: Docs Deploy
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: app/vue/docs/.vitepress/dist

      # 새 빌드만 업로드 (전체 static이 아닌)
      - name: Upload new build to server
        env:
          BUILD_TIMESTAMP: ${{ github.run_number }}_${{ github.sha }}
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.CICD_HOST }}
          username: ${{ secrets.CICD_USER }}
          password: ${{ secrets.CICD_PASS }}
          source: 'app/django/static/dist_${{ github.run_number }}_${{ github.sha }}'
          target: ${{ secrets.CICD_PATH }}/prod/app/django/static/

      # SCP 후 파일 무결성 검증
      - name: Verify upload integrity
        env:
          BUILD_TIMESTAMP: ${{ github.run_number }}_${{ github.sha }}
        uses: garygrossgarten/github-action-ssh@release
        with:
          host: ${{ secrets.CICD_HOST }}
          username: ${{ secrets.CICD_USER }}
          password: ${{ secrets.CICD_PASS }}
          command: |
            cd ${{ secrets.CICD_PATH }}/prod/app/django/static
            NEW_BUILD="dist_${{ github.run_number }}_${{ github.sha }}"

            echo "🔍 Verifying uploaded files for: $NEW_BUILD"

            # 빌드 디렉터리 존재 확인
            if [ ! -d "$NEW_BUILD" ]; then
              echo "❌ ERROR: Build directory not found: $NEW_BUILD"
              exit 1
            fi

            # index.html 존재 확인
            if [ ! -f "$NEW_BUILD/index.html" ]; then
              echo "❌ ERROR: index.html not uploaded!"
              exit 1
            fi

            # assets 디렉터리 확인
            if [ ! -d "$NEW_BUILD/assets" ]; then
              echo "❌ ERROR: assets directory not uploaded!"
              exit 1
            fi

            # assets 파일 개수 확인 (최소 기대값)
            ASSET_COUNT=$(find "$NEW_BUILD/assets" -type f 2>/dev/null | wc -l)
            if [ "$ASSET_COUNT" -lt 10 ]; then
              echo "❌ ERROR: Too few assets uploaded ($ASSET_COUNT files)"
              echo "Expected at least 10 asset files"
              exit 1
            fi

            # index.html이 참조하는 주요 JS 파일 존재 확인
            MAIN_JS=$(grep -o 'assets/index-[^"]*\.js' "$NEW_BUILD/index.html" 2>/dev/null | head -1)
            if [ -n "$MAIN_JS" ]; then
              if [ ! -f "$NEW_BUILD/$MAIN_JS" ]; then
                echo "❌ ERROR: Referenced main JS file missing: $MAIN_JS"
                exit 1
              fi
              echo "  ✓ Main JS verified: $MAIN_JS"
            fi

            # CSS 파일 존재 확인
            CSS_COUNT=$(find "$NEW_BUILD/assets" -name "*.css" 2>/dev/null | wc -l)
            if [ "$CSS_COUNT" -eq 0 ]; then
              echo "⚠️  WARNING: No CSS files found!"
            else
              echo "  ✓ CSS files: $CSS_COUNT"
            fi

            echo "✅ Upload integrity verified"
            echo "📊 Upload summary:"

            # index.html 크기 (에러 처리 추가)
            if [ -f "$NEW_BUILD/index.html" ]; then
              INDEX_SIZE=$(wc -c < "$NEW_BUILD/index.html" 2>&1) || INDEX_SIZE="error"
              echo "  - index.html: $INDEX_SIZE bytes"
            else
              echo "  - index.html: MISSING"
            fi

            echo "  - Total assets: $ASSET_COUNT files"

            # 디렉터리 크기 (에러 처리 추가)
            TOTAL_SIZE=$(du -sh "$NEW_BUILD" 2>&1 | cut -f1) || TOTAL_SIZE="error"
            echo "  - Total size: $TOTAL_SIZE"

            # 디버깅: 최종 exit code 명시
            echo "  - Verification exit code: 0"
            exit 0

      # 원자적 배포 (Symlink Swap)
      - name: Atomic deployment with symlink swap
        env:
          BUILD_TIMESTAMP: ${{ github.run_number }}_${{ github.sha }}
        uses: garygrossgarten/github-action-ssh@release
        with:
          host: ${{ secrets.CICD_HOST }}
          username: ${{ secrets.CICD_USER }}
          password: ${{ secrets.CICD_PASS }}
          command: |
            cd ${{ secrets.CICD_PATH }}/prod/app/django/static

            # 새 빌드 디렉터리명
            NEW_BUILD="dist_${{ github.run_number }}_${{ github.sha }}"

            echo "📦 Deploying: $NEW_BUILD"

            # 새 빌드 디렉터리 존재 재확인
            if [ ! -d "$NEW_BUILD" ]; then
              echo "❌ ERROR: Build directory not found: $NEW_BUILD"
              exit 1
            fi

            # 이전 활성 빌드 기록 (롤백용)
            if [ -L "dist" ]; then
              PREVIOUS_BUILD=$(readlink dist)
              echo "Previous build: $PREVIOUS_BUILD"
            fi

            # 심볼릭 링크 원자적 교체
            ln -sfn "$NEW_BUILD" dist.tmp
            mv -Tf dist.tmp dist

            # 심볼릭 링크 검증
            if [ ! -L "dist" ]; then
              echo "❌ ERROR: Failed to create symlink!"
              exit 1
            fi

            CURRENT_LINK=$(readlink dist)
            if [ "$CURRENT_LINK" != "$NEW_BUILD" ]; then
              echo "❌ ERROR: Symlink points to wrong target: $CURRENT_LINK"
              exit 1
            fi

            # 심볼릭 링크가 실제 디렉터리를 가리키는지 확인 (깨진 링크 방지)
            if [ ! -d "dist" ]; then
              echo "❌ ERROR: Symlink is broken! Rolling back..."
              if [ -n "$PREVIOUS_BUILD" ] && [ -d "$PREVIOUS_BUILD" ]; then
                ln -sfn "$PREVIOUS_BUILD" dist.tmp
                mv -Tf dist.tmp dist
                echo "Rolled back to: $PREVIOUS_BUILD"
              fi
              exit 1
            fi

            echo "✅ Symlink verified: dist -> $CURRENT_LINK"

            # 안전한 구 빌드 정리 (최근 3개 유지로 증가)
            echo ""
            echo "🧹 Cleaning old builds (keeping 3 most recent)..."

            # 모든 빌드 디렉터리 나열 (시간순 역순)
            ALL_BUILDS=$(ls -dt dist_* 2>/dev/null)
            BUILD_COUNT=$(echo "$ALL_BUILDS" | wc -l)

            echo "Total builds found: $BUILD_COUNT"

            # 최근 3개 제외하고 삭제
            if [ "$BUILD_COUNT" -gt 3 ]; then
              echo "$ALL_BUILDS" | tail -n +4 | while read OLD_BUILD; do
                # 현재 활성 빌드는 절대 삭제 안 함 (이중 안전장치)
                if [ "$OLD_BUILD" != "$CURRENT_LINK" ]; then
                  echo "  Removing: $OLD_BUILD"
                  rm -rf "$OLD_BUILD"
                else
                  echo "  Skipping active build: $OLD_BUILD"
                fi
              done
            fi

            echo ""
            echo "✅ Deployment complete!"
            echo "📊 Current state:"
            echo "  Active: $(readlink dist)"
            echo "  Remaining builds:"
            ls -lth | grep "^d" | grep "dist_" | head -5

      # NFS 동기화 대기
      - name: Wait for NFS sync
        run: |
          echo "⏳ Waiting for NFS synchronization..."
          sleep 5
          echo "✅ NFS sync complete"

      # 배포 검증 (파일 무결성 확인)
      - name: Verify deployment integrity
        uses: garygrossgarten/github-action-ssh@release
        with:
          host: ${{ secrets.CICD_HOST }}
          username: ${{ secrets.CICD_USER }}
          password: ${{ secrets.CICD_PASS }}
          command: |
            cd ${{ secrets.CICD_PATH }}/prod/app/django/static

            echo "🔍 Verifying deployment integrity..."

            # index.html 존재 확인
            if [ ! -f "dist/index.html" ]; then
              echo "❌ Deployment failed: index.html not found"
              exit 1
            fi

            # assets 디렉터리 확인
            if [ ! -d "dist/assets" ]; then
              echo "❌ Deployment failed: assets directory not found"
              exit 1
            fi

            # index.html이 참조하는 주요 파일 존재 확인
            MAIN_JS=$(grep -o 'assets/index-[^"]*\.js' dist/index.html 2>/dev/null | head -1)
            if [ -n "$MAIN_JS" ]; then
              if [ ! -f "dist/$MAIN_JS" ]; then
                echo "❌ Deployment failed: Referenced main JS missing: $MAIN_JS"
                echo "Available index JS files:"
                ls -lh dist/assets/index-*.js 2>/dev/null || echo "  None found!"
                exit 1
              fi
              echo "  ✓ Main JS exists: $MAIN_JS"
            else
              echo "⚠️  WARNING: Could not detect main JS reference in index.html"
            fi

            # CSS 파일 확인
            CSS_COUNT=$(find dist/assets -name "*.css" 2>/dev/null | wc -l)
            if [ "$CSS_COUNT" -eq 0 ]; then
              echo "❌ ERROR: No CSS files found in deployment!"
              exit 1
            fi
            echo "  ✓ CSS files: $CSS_COUNT"

            # 전체 assets 개수 확인
            TOTAL_ASSETS=$(find dist/assets -type f 2>/dev/null | wc -l)
            echo "  ✓ Total assets: $TOTAL_ASSETS"

            # 배포 정보 출력
            echo ""
            echo "✅ Deployment integrity verified"
            echo "📊 Deployment info:"
            if [ -f "dist/deploy.json" ]; then
              cat dist/deploy.json
            fi
            echo ""
            echo "Active build: $(readlink dist)"

      # Kubernetes Pod 재시작 (Django 템플릿 캐시 클리어)
      - name: Restart web and nginx pods
        uses: garygrossgarten/github-action-ssh@release
        with:
          host: ${{ secrets.CICD_HOST }}
          username: ${{ secrets.CICD_USER }}
          password: ${{ secrets.CICD_PASS }}
          command: |
            echo "🔄 Restarting Nginx and Web pods..."
            kubectl rollout restart deployment/nginx -n ibs-prod
            kubectl rollout restart deployment/web -n ibs-prod

            echo "⏳ Waiting for rollout to complete..."
            kubectl rollout status deployment/nginx -n ibs-prod --timeout=120s
            kubectl rollout status deployment/web -n ibs-prod --timeout=120s

            echo "✅ Pods restarted successfully"

      # web pod --> fetch_commits
      - name: Django fetch_commits
        uses: garygrossgarten/github-action-ssh@release
        with:
          host: ${{ secrets.CICD_HOST }}
          username: ${{ secrets.CICD_USER }}
          password: ${{ secrets.CICD_PASS }}
          command: |
            web_pod=$(kubectl get pod -n ibs-prod | grep web | head -n 1 | cut -d ' ' -f1)
            kubectl exec -it -n ibs-prod $web_pod -- python manage.py fetch_commits
      
      # slack --> notification
      - name: Send slack when failed
        if: ${{ failure() }}                    # 실패했을 때 실행
        uses: ./.github/actions/slack-notify    # 직접 '만든' Action이므로 uses 키워드를 이용해서 아래 경로를 입력해줍니다.
        with:
          slack_incoming_url: ${{ secrets.SLACK_INCOMING_URL }}

      - name: Send slack if completed
        if: ${{ success() }}                    # 성공할 때만 실행
        uses: ./.github/actions/slack-notify
        with:
          status: success   # status input은 받는 쪽에서 default 값을 정해놨기 때문에 success일 때만 전달.
          slack_incoming_url: ${{ secrets.SLACK_INCOMING_URL }}
